# VGP Tools: The VGP tool kit and formats

## Authors:  Gene Myers, Richard Durbin and the Vertebrate Genome Project assembly group
## _Date: February 18-22, 2019_

VGP-Tools is a collection of tools that operate on DNA sequencing data encoded in a collection
of file formats called collectively VGP-Formats.  The encodings include descriptions of source
data, process intermediates, and the ultimate reconstructed genome assemblies.  There is a core set of ASCII file types based on very simple principles, then specific derived subtypes that add additional constraints in order to represent specific data types.
For example, the
VGP currently collects four core data sets as input into a genome assembly. Three of these are encoded in three different subtypes of the sequence file type, and the fourth in a restriction map file type.  

Below are the file types currently supported by VGP-Formats. By convention file types and subtypes are three letter lower case strings, which can be used as filename suffixes, e.g. dataset1.seq or dataset2.pbr.

- **.seq**   primary file type for sequence objects. There are multiple subtypes of this including
	- **.irp** for Illumina read pairs, which we use to encode Hi-C read data but which can be applied more generally to any read pair protocol,
	- **.pbr** for PacBio long reads and relevant meta-data, 
	- **.10x** for 10X Genomics read clouds with their extracted barcodes,
	- **.ctg** for contigs from an assembly.

- **.rmd**   primary type for restriction map digests.  We use this for primary BioNano .bnx data, but also for derived restriction maps either generated by assembly from primary data, or by *in silico* digestion from sequences.  Subtypes are
	- **.rmb** for BioNano raw data imported from .bnx files
	- **.rmc** for contigs from map assembly as in Bionano .cmap output of their "solve" assembly process

- **.sxs**   primary type for sequence alignments (Sequence Cross Sequence, pronounced like "success").  Subtypes of this are
	- **.rxr** for restriction map comparisons, and 
	- **.map** for representing the relationship between a set of consensus sequences and the reads or other sequences from which they were derived.

- **.jns** a collection of scaffolding suggestions representing putative joins between sequences in some .seq file.  This can also be used to represent possible links between sequence contigs in an assembly graph.

- **.brk** a collection of scaffolding suggestions representing putative breaks in sequences in some .seq file.

- **.scf** this supports export of a set of scaffolds or sequences from a VGP-Format file collection as fasta and/or agp with gaps.

- **.lis** this is a utility file type can be used to record arbitrary lists of objects in any of the other types.

The VGP format encoding of each file type is documented in a separate chapter of this document following the overview
given here.  The formal definition of all currently valid specs is provided in the code for the utility **vgpvalidate**
which also provides utilities to reconstruct headers.  The design of VGP formats is based on the following principles:

1.	The format should be trivial to parse as input.  All the burden of encoding is placed on the software that produces the formatted file.

2.	The length of a list should always precede the list (e.g. 3 xxx).  Bracket (.eg [xxx]) or terminator (e.g. xxx0) constructions are not permitted.

3.	The maximum size or total size of items to follow should be specified at the start of a file so that any desired memory allocation can be performed once at the start by the reader.

4.	For every format file type, there is a VGP tool that translates the ASCII format to a terse binary form and another that inverts this conversion.

5.	The ASCII form should not be overly verbose, it is not for human consumption, but simply must be easily interpretable by a human being when and if they need to look at the data.

6.	Complex identifiers or symbolic names for objects are not used.  The nth occurrence of an object of a given type is referred to by the number n in any future context within the file.

7.	A reference to an object is not permitted before its definition.

8.	The provenance of a file must be given as the sequence of tools applied to obtain it, where each tool application is described by its name, version number, command line applied, and date & time performed. 

From another point of view, a VGP formatted file should be readable by a simple parser that can
(a) read the next integer, (b) read the next real number, (c) read the next n symbols, and
(d) skip to the next line, where each read can begin with white space that is skipped.  The
parser should further never require dynamic memory allocation to store objects – the size of
any object or object collection should be given before the first object of that type is described.

Following these principles, VGP formats uses a very simple “1-code” schema in which the data is
encoded in an ASCII file in a sequence of lines where the first character of each line determines
what kind of information the line encodes.  Consider as a working example, the following Illumina Read Pair (irp) file:

```
1 3 seq 1 0            required file type, major and minor version
2 3 irp                optional subtype
# ! 1                  number of provenance lines in the file
# P 2                  number of read pairs in file
# S 4                  number of sequences in file
@ S 5                  maximum number of bp’s in a read
+ S 17                 total number of bp's in file
! 7 VGPpair 3 0.1 ...  provenance line saying how file arose
P                      separator for read pairs - helps human interpretability 
S 5 acgta              forward sequence of pair 1
S 3 gtt                reverse sequence of pair 1
P
S 4 gcta
S 5 ggtac 
```
Like all VGP files, this starts with a set of header lines indicated by a non-alphabetic "1-code" symbol, followed by data lines that always begin with an alphabetic "1-code".  Tokens on a line are separated by a single whitespace character (space or tab).  Variable length lists, including strings, are preceded by their length in keeping with principle 2. The
1-code and subsequent tokens determine when the encoding of expected information on a line is at an end. 
Therefore optional additional information to the end of the line provides an extensibility
mechanism where one can add auxiliary information if desired.  In the example above, the whitespace and 
comments following the encoded information on each line are ignored by a VGP parser.

A further consequence of the 1-code philosophy of VGP lines is that once the initial symbol is read, all the other fields are required.  For this reason, when we want to allow optional information for an object, it must be encoded on separate lines with their own line types that follow the object definition line.

Conceptually VGP files are *immutable*, meaning that we do not expect their contents to change. This means that subsequently in the same file, or more often in future files in a pipeline, we can refer to objects by their ordinal position in a file, 1...n, not requiring named identifiers. This simplifies many things.

### Header lines

Considerable effort is invested on headers in VGP-formats in keeping with principles 3 and 8.

The first header line with type ```1``` must always be a version line confirming the file type and specifying the major and minor
version numbers separated by a whitespace.  This can optionally be followed immediately by a file subtype line with type ```2``` as in the example above 

Additional header lines give information about the number of items
in the file (#-lines), the maximum length of lists (@-lines), and the total number of items in a given list class
(+-lines).  In addition, provenance lines (!-lines) inform one about how the particular file came to be.

We now introduce how we formally describe VGP formats, defining the header lines to illustrate. Using a "casual" context free grammar rule the inital file type declaration has the syntax:

```
    <version_header> = 1 <string:file_type> <major> <minor>
```
where the initial ```1``` indicates that this is a a "1-code" file (as well as this being line 1) and ```<file_type>``` is one of the nine 3-letter file suffixes above.  In accordance with principle 3, strings are encoded with an initial integer giving their length, followed by the literal string of characters, which can contain whitespace other than newlines.

```
   <string> = <int:n> <char>n
```
The initial header line can be followed by an optional subtype line

```
	<subtype_header> = 2 <string:file_subtype>
```
***Gene asks whether the secondary should have a version number?***

Next there are three header line types - #, +, and @ - that allow one to specify the number, total size, and maximum size of objects across a file.  These all have the syntax:

```
    <size_header> = [#+@] <symbol:S> <int>
```
```#```-lines tell you the number of lines in the file of type S.  For line types that encode a list of items, such as
string (a list of characters) or say a list of digest sites, a ```+```-line tells you the total number of items
in all the lists in the file, e.g. "<code>+ S 17</code>" in the example above indicates that altogether the
sequences in the file total 17 bases.  Similarly, an ```@```-line indicates the length of the largest list that
occurs in any given line of the specified type.  

Often the objects in a file are naturally partitioned into groups, e.g. all the read pairs in a flow-cell lane, and the VGP formats support this with lower case symbols as data line indicators.  For these the ```%``` designator indicates the maximum number of objects or total size of list objects within any given group type.  The syntax for these lines is:  

```
    <group_header> = % <symbol:g> [#+] <symbol:S> <int>
```
where ```<g>``` is the group line designator (always a lower case letter by convention) and ```<S>``` is the line type in question.

Another important header line type indicates that references in this file are made to objects in another file. This has the following syntax

```
    <reference_header> = '<' <string:file_name> <symbol:X> <int:nx>
```
The X symbol in this line denotes the line type from the referenced file which identifies the objects to be referred to.  For example an alignment file may refer to sequence objects designated by S lines in another file. The nx number is the number of these items.

A related concept is to refer to another file in which the objects depends upon the contents of the current file.  We denote this in a similar way to the reference line, but with a '>' symbol rather than a '<' symbol.

```
	<forward_header> = '>' <string:file_name>
```
In this case there is no need to indicate the primary objects in the file and their number, since the current file will not refer to them.

The final header line type is provenance or ```!```-lines that record a processing step that was involved
in producing the current file.  Each line contains four strings giving (a) the program name, (b) the version of that program as a string, (c) the command line that was executed, and (d) the date and time it
was run.

```
    <provenance_step> = <string:name> <string:version> <string:command> <string:date>
```

## Data lines defined according to file type

The types of data lines permitted depend on the file type.  We therefore specify here each file type in turn.  Where reference header lines are required we indicate that here, together with what they signify. We remind the reader that while we aim to keep this README up to date, the formal versioned definition of each VGP file type is determined by the validator **VGPvalidate** and documented in its code.

### Sequence, .seq

A core file type containing sequences, with optional additional information, in particular quality scores as in FASTQ. Further legal additional lines are described in the subtypes listed below.

```
g <int:n> <string:group_name>    group with n sequences
P              indicates that the next two sequences are paired
S <string>     the sequence
Q <string>     QV scores in single character phred encoding (ASCII 33+q) 
```
The core lines are the S lines, and this is the only line type which is required. If Q lines are present then the number of Q lines must be the same as the number of S lines. If P lines are present for pairing, then the number of S lines must be twice the number of P lines.  

The S strings are over the alphabet A, C, G, T.  IUPAC ambiguity codes are not supported. Any unsupported code (including N) is turned into an arbitrary letter with by VGP tools, with quality set to 0 if qualities are present.  DNA strings may be upper or lower case.

The Q lines are optional.  When present, each symbol of a Q string is an ASCII character as encoded in FASTQ.  So Q strings are over the 94 printable ASCII characters [!-~] and correspond to the range 0 to 93.

The g lines are also optional. If present they must form a partition over the sequences, that is every S line must be contained in one and only one group. If pairs are present then both the reads in a pair must be in the same group.  We use the g lines both for read groups in primary Illumina data, and for read clouds in 10X Genomics data, where we place the barcode in the group_name field.

#### Illumina paired reads, .ipr

This subtype of .seq requires that P lines exist.

If group lines are present then they should correspond to sequencing lanes or the equivalent, as in SAM read groups.

**VGPpair** is a VGP tool that takes two .fastq files containing corresponding forward and reverse reads (the usual bioinformatic convention for such) and produces a .irp from the inputs.  Reads within the same lane are placed in a given group. 

#### 10X Genomics read clouds, .10x

This subtype is for processed 10x sequencing data. It requires paired reads as for .ipr and that barcodes and linker sequences have been removed from the sequences (the first 23bp = 16bp barcode and 7bp linker from the start of the first read). It also requires that g lines exist and correspond to subsets of reads with the same barcode.  The literal barcode sequence is by convention given in the group_name field.

**VGPcloud** is a VGP tool that takes an .irp-file containing the bar-coded Illumina read pairs
and re-organizes the data into clouds and removes the bar codes.  It understands how barcodes
are encoded in the forward read of each pair, and takes into account potential errors in the
barcode sequence.

#### PacBio long reads, .pbr

The final raw data .seq subtype for the time being encodes long reads from Pacific Biosciences.  P is not permitted, and the g group_name should be set to the SMRT_cell header.  In addition a W line must be provided for each sequence as below in order to give well information for the read.  We also allow two extra optional record types to encode signal information that can be used in consensus calling and polishing.

```
W <int:well> <int:1st.pulse> <int:last.pulse> <real:score>	read well and pulse range
N <real:A> <real:C> <real:G> <real:T>   SNR in each base channel for read
A <string>                              capped pulse widths
```
The W line is necessary to identify when multiple subreads come from the same well. If present, the N-line give the average SNR in the channels for each base and
the A-line gives the capped pulse width for each base as the character 1, 2, 3 or 4.  Pulse
widths larger than 4 are clipped to 4 as Arrow does not treat widths larger than 4 differently.
Basically short pulses are indications of potential error but any pulse over 4 units
long is almost certainly a good call.  The A string must have the same length as the S string for a given read .

**VGPpacbio** is a VGP tool that takes one or more Pacbio subreads.bam or .sam files as input
and extracts the information to make a .pbr file.

#### Contig files from assemblies, .ctg

This sequence type is the product of an assembler.  If at all possible there should be an associated **.map** file, which records the alignments of reads that generated the contig, and **.scf** file which records the potential joins between contigs at branch points in the assembly graph. In the header notation described above these would be

```
> <string:map_file_name>
> <string:scaffold_information_name>
```

### Restriction Map Digest, .rmd

This file type encodes a general restriction digest, potentially with multiple enzymes with distinct recognition sites. 

```
r <int:r> <int:s> <string:site>s	set of r map objects cut with s enzymes, giving the literal recognition sequences of the enzymes
R <int:len> <int:n> <int>n       	restriction map: length and list of site locations in bases
E <int:n> <int>n					list of enzyme type per site (from 1..s)
```
The required lines are at least one r group line giving the restriction recognition sequence, or set of sequences, for the data in the following group, then a set of R lines that give the actual map objects with the site locations in each map in ascending order.  When multiple enzymes are used then there must be a corresponding E line for each R line, which specifies which enzyme/recognition sequence applies to each site in the map object.

We envision three subtypes

#### Restriction Map from Sequence, .rms

When the file is used to represent *in silico* digestions of sequences,  then there must be a reference header giving the source of the sequence, and for each R line an O line referring back to the relevant sequence object.

```
< <string:ref_sequence_filename> S <int:ns>

O <int>
```

#### BioNano raw data, .rmb

This subtype supports raw BioNano data from a .bnx file by adding two additional required lines for each R line:

```
I <int:n> <real>n    				list of n intensities of sites in digest
N <int:n> <real>n    		 		list of n signal to noise ratios per site
```

**VGPbionano** is a VGP tool that takes a Bionano .bnx-file as input and extracts the information to make a .rmd-file.

#### BioNano assembled map, .rmc

This is a subtype with the potential to record additional information from map assembly.

BioNano Solve generates cmap files with many additional attributes per site, including a standard deviation, coverage depth, occurrence depth (how many of input map molecules that cover this site contain this site) and scores for the chance of this site being adjacent to a chimeric join or a fragile site.  We could additional line types analogous to E to support any of these that we feel is important to be recorded for downstream analysis.

It can be used both to represent primary data from a BioNano .bnx file, or other source of primary data, or a virtual map derived either by assembly of primary data or by *in silico* digestion of a sequence given a restriction enzyme recognition site, corresponding to the .cmap file type in the BioNano world.  These can be used for consistency checks with proposed assemblies, and to make inferences about scaffolding breaks and joins. 
The R line is only required if there are multiple enzymes specified (s > 1).  

In terms of a regular expression:

```
( <r-line> (<R-line> [<E-line>][<I-line>][<N-line>])r )*
```

### Sequence match files, .sxs

This is the primary file type for sequence matches, with "sxs" standing for Sequence Cross Sequence, pronounced like "success".

```
< <string:filename_a> <char:X> <int:na>        source of A sequences
< <string:filename_b> <char:Y> <int:nb>        source of B sequences

A <int:a> <int:b>                       indexes of aligned sequences
I <int:as> <int:ae> <int:bs> <int:be>   start and end in a and in b
Q <int>                                 alignment confidence in phred units
C <string>                              cigar string
T <int:t> <int>t                        list of trace points
U <int:u> <int>u                        list of trace sites in a
V <int:u> <int>u                        list of trace sites in b
M <int>                                 number of matching aligned bases
D <int>                                 number of differences = substitutions + indel bases
```
There must be two included files, each containing some number of lines of their respective named type, here *X* and *Y*.  For standard sequence matches both *X* and *Y* will be S.  We allow an arbitrary type here so as to also allow restriction map lines from **.rmd** files (see subtype .rxr below). It is these objects that the ```a``` and ```b``` index fields on the ```A``` alignment lines refer to.  The two files can be the same in the case that an all-versus-all alignment process has been run, as in the first step of most assemblers.

The integers in the I line give the start and end coordinates in a and b in semi-open format [*as,ae*), so *as* = 0 corresponds to the first base, and *ae* = len means to finish at the last base (bases numbered 0..len-1).  If the sequences align in opposite directions then *ae* > *as* and *be* < *bs*, with the aligned b sequence being the reverse complement of [*be*,*bs*).

The value in the Q field is the phred-scaled confidence that the alignment is true, which is defined as -10log<sub>10</sub> p(alignment is false). This is the mapping quality for programs that generate it. Otherwise programs that want to give score information should provide an estimate. This can be followed by other method-specific scoring information, which because it falls after the defined fields can be free form.

There are mutliple ways to give more detailed information about the alignment.  A C line supports CIGAR, which gives the complete alignment but can be verbose if the divergence is high.  The T line gives trace points corresponding mapping evenly spaced positions in the a sequences, as in Gene Myers' [DAZZLER](https://dazzlerblog.wordpress.com/2015/11/05/trace-points/) system. A variant of this is to provide paired trace coordinates in both sequences, encoded in U and V lines.  In particular these are used during restriction map alignment (see below).

All line types following A are optional.  Typically I will be present and only one of C or T or (U and V) will be used downstream by any one application.

If there are *a* bases in sequence a and *b* bases in sequence b and *m* matches, *s* substitutions, *d* deletions and *i* insertions, then  M = *m* and D = *s* + *i* + *d*. So if we have both M and D then we can calculate *s* and *i* and *d*, using that 2*m* + 2*s* + *i* + *d* = *a* + *b* and *m* + *s* + *d* = *a* and *m* + *s* + *i* = *b*.

#### Restriction digest match file, .rxr

This is a subtype to represent restriction map comparisons, as in the .xmap files produced by the BioNano Hybrid Scaffold process.  In this case the reference files will be .rmd files containing R lines, and the coordinates are restriction sites, not bases. It should in principle be possible to create .rxs files that compare restriction maps to sequences without an intermediate in silico digest file, but we are not currently aware of software to do this.

#### Sequence map file, .map

A different special case of a .sxs file is when a sequence is derived from one or more previous sequences, for example following an edit process during assembly polishing, or as the golden path consensus of a multiple alignment of read subsequences.  In this case each sequence in file A must be completely covered by an alignment, so that every base can be traced back.  In this case C lines are necessary to specify the alignment exactly.

It is possible in principle to compose .map files so as to support tracing back coordinates in a current set of sequences to those in previous sets.

### Joins file, .jns

This file type encodes possible joins between sequences.  We use this both for possible scaffolding joins, and to indicate edges between sequence nodes in an assembly graph. 

For assemblies, we expect that our assembly process will create a **.seq** file of contigs, and that various methods will be applied to use 10X Genomics, BioNano, HiC and/or other data to propose joins between these contigs, and possible breaks in them where they believe that there were missassemblies. This file type encodes the possible joins, and the following file type encodes possible breaks. We envision that there will be a program that can act on contig file together with lists of breaks and joins to create new contig files, or scaffolds (see .scf file type below).

```
< <string:contig_file_name> S <int:nseqs>
< <string:sxs_file_name> A <int:nalignments>

J <int:seq_a> <int:seq_b> <[s|e]:end_a> <[s|e]:end_b>   potential join
G <int:gap_size>
Q <int:phred_confidence>                                optional score of confidence in the join
X <int:na> <int:a>n                                     optional list of alignment objects providing evidence for the break
```

The J line specifies which end of each sequence is involved in the join, using single characters ***s*** or ***e*** to designate the start and end.  

The G line indicates the expected gap size.  If the G line is missing then the sequences are presumed to abut. If the gap is negative then they overlap by the specified number of bases.

An optional Q line encodes confidence in the assertion of the break. As in .sxs files, this is encoded in phred-scaled units *q* = -10log<sub>10</sub> p(break or join is false).  Further score information from the specific method that proposed the join can be given after the phred score.

An optional X line points to evidence for the join assertion, in the form of a list of alignments.  If this is present then the there must be a reference to a .sxs file in the header.

### Breaks file, .brk

This file encodes information about possible breaks in sequences. See the description of the .jns file type explains how we envision that these will be used.

```
< <string:contig_file_name> S <int:nseqs>
< <string:sxs_file_name> A <int:nalignments>

B <int:seq> <int:start> <int:end>    potential break in sequence somewhere between start and end
Q <int:phred_confidence>             optional score of confidence in the break
X <int:na> <int:a>n                  optional list of alignment objects providing evidence for the break
```

The B line indicates a potential break.  The meaning is that the break is to the right of position *seq_a* and to the left of position *seq_b*, so if the breakpoint is known exactly then *seq_b* = *seq_a* + 1. In practice most scaffolding programs typically can only localise possible breaks to a wider interval. 

The Q and X lines have the same interpretation as in .jns files. For completeness we repeat this information here again.

A Q line can be present to indicate confidence in the assertion of the break. As in .sxs files, this is encoded in phred-scaled units *q* = -10log<sub>10</sub> p(break or join is false).  Further score information specific to the method used to infer the break can be given after the phred score.

An optional X line points to evidence for the break assertion, in the form of list of alignments.  If this is present then the there must be a reference to a .sxs file in the header.

### Scaffold file, .scf

Because our basic sequence objects do not allow gaps, we need a separate file type to represent scaffolds.  Since this will also be used for export of the final product of assemblies at this point we also support object names, so as, for example, to be able to name chromosomes or other well-known sequences.

```
< <string:seq_filename> S <int:ns>
< <string:sxf_filename> J <int:nj>

F <int:s> <char:+|-> <int:k> <int:j>k  starting sequence, orientation, list of joins
N <string:name>
```
Each scaffold is defined by a starting sequence with its orientation and a (possibly empty) list of join objects.  There is an optional name.

This structure supports generation of fasta with gaps filled with N's, and generation of the Assembly Golden Path (agp) format.

### List file, .lis

This file type just keeps lists of indexes into other VGP file types.  We use this to define subsets of objects in existing VGP files, without needing to create

```
< <string:file_name> X <int:nx>
	
L <int:n> <int>n
```
There must be one input header line, and can be an arbitrary number of L lines. Here ```X``` in the header line is a line type found nx times in the named included file, the n value on an L line determines the number of items in the list, and each item is a positive integer between 1 and nx.

## A possible assembly work flow

We view the assembly task as choice of a subset of read alignments that
result in a consistent layout.  These can then be used to generate
consensus contig sequences, with possible joins at branch points.  While a read may overlap multiple contigs, our convention is that contigs do not overlap, but rather abut at junctions.  Explicitly representing the subset of alignments to be used allows different tools to be used to generate alignments, select the spanning subset, then generate the graph and consensus contig sequences.

Following this different scaffolding programs may generate lists of possible breaks and joins, which can be applied in some order to generate longer contigs

Below is pseudocode for a somewhat fanciful standard assembly pipeline. In practice we do not envision working the whole time with VGP formats.  Certain series of operations will naturally be carried out on data in a native binary format.  However, we propose to require that all of our tools can convert back and forth into VGP formats to permit interchange of information.

```
// edit and assemble PacBio data
VGPpacbio pb1.bam pb2.bam pb3.bam > pb-raw.pbr
long_read_compare pb-raw.pbr pb-raw.pbr > pb-raw.sxs
pb_edit pb-raw.sxs > (pb-clean.seq, pb-clean.map)
long_read_compare pb-clean.pbr pb-clean.pbr > pb-clean.sxs
transitive_reduction pb-clean.sxs > pb-clean.lis
build_consensus pb-clean.lis > (contigs1.ctg, contigs1.map, contigs1.sxf)

// short range scaffold with 10x data
VGPpair tenx.R1.fastq.gz tenx.R2.fastq.gz > tenx.ipr
VGPcloud tenx.ipr > tenx.10x
read_map contigs1.ctg tenx.10x > tenx.sxs
scaff_10x contigs1.ctg tenx.sxs > tenx.scf
apply_scf contigs1.ctg tenx.scf > (contigs2.ctg, contigs2.map, contigs2.sxf)

// long range scaffold with BioNano data
bnx2rmb bionan.bnx > bionan.rmb
rmd_assemble bionan.rmd > (bionan.rmc, bionan.map)
digest_compare contigs2.ctg bionan.rmc > bionan.sxr
scaff_rmc contigs2.ctg bionan.sxr > bionan.scf
apply_scf contigs2.ctg bionan.scf > (contigs3.ctg, contigs3.map, contigs3.sxf)

// scaffold to chromosomes with HiC data
VGPpair hic.R1.fastq.gz hic2.R2.fastq.gz > hic.ipr
read_map contigs3.ctg hic.ipr > hic.sxs
scaff_hic contigs3.ctg hic.sxs > hic.scf
apply_scf contigs3.ctg bionan.scf > (contigs4.ctg, contigs4.map, contigs4.sxf)

// build scaffold objects
select_scaffolds contigs4.ctg contigs4.sxf > scaffolds4.exs

// and polish, first with PacBio data
compose_maps contigs4.map contigs3.map contigs2.map contigs1.map pb-clean.map > contigs4-pbraw.map
pb_polish contigs4.ctg scaffolds4.exs contigs4-pbraw.map pb-raw.pbr > (contigs5.ctg, scaffolds5.exs contigs5.map)

// and then with 10x Illumina data
read_map contigs5.ctg tenx.10x > contigs5-tenx.sxs
illumina_polish contigs5.ctg scaffolds5.exs contigs5-tenx.sxs > (contigs6.ctg, scaffolds6.exs contigs6.map)

// finally export the scaffolds into fasta for everyone to use
export_fasta contigs6.ctg scaffolds6.exs > assembly.fa
export_agp scaffold6.exs > assembly.agp
```
An alternative enabled by having proposed scaffolding operations in VGP formats would be to first make all the .scf files then select a consensus of them, and apply this to generate the final contig and scaffold sets.  This process could perhaps be repeated once, to allow joining ends of contigs that had been broken.

# VGP Tool Manuals

```
1. VGPpair [-vsg] <forward:fastq> <reverse:fastq>
```

VGPpair reads two correlated fastq files and outputs the pairs in .irp format to the
standard output.

The input file names must have a .fastq suffix, e.g. somewhere/foo.fastq, however
the suffix need not be given on the command line as VGPpair will automatically add the
appropriate suffix if it is not present.  That is, "<code>VGPpair foo1 foo2</code>" will
operate on <code>foo1.fastq</code> and <code>foo2.fastq</code>.

The -v option asks VGPpair to output information on its progress to the standard error.
The -s option asks VGPpair to *not* output the quality values or Q-lines, but just the
forward and reverse sequences in F- and R-lines.
The -g option asks VGPpair to group the data into lanes.  In this case the files must
have been produced by standard Illumina software from their more basic .bcl files, and
therefore the .fastq headers encode the instrument, flow cell, lane, etc. in fields
between :'s where the data is in order of flow cell and lane.  VGPpair uses this
information to group reads into lanes.

VGPpair checks the syntax of the .fastq files but does not verify that the DNA and QV
strings are over the appropriate symbols.

```
2. VGPpacbio [-vaU] <data:subreads.[bam|sam]> ...
```

VGPpacbio reads a sequence of Pacbio .bam or .sam files and outputs a .brp file to
standard output.

The input file names must have a .bam or .sam suffix, e.g. somewhere/foo.bam, however
the suffix need not be given on the command line as VGPpacbio will automatically add the
appropriate suffix if it is not present.  That is, "<code>VGPpacbio foo1 foo2</code>" will
operate on <code>foo1.bam</code> and <code>foo2.sam</code> if those are the files present.

The -v option asks VGPpacbio to output information on its progress to the standard error.
The -a option asks VGPpacbio to  output the arrow information in N- and A-lines per bundle,
the default is to not output this information.  The -U option requests that the DNA seuqences
are in upper case (the default is lower case).

Each file is forms a separate group in the output file.
