# VGP Tools: The VGP tool kit and formats

## Authors:  Gene Myers, Richard Durbin and the Vertebrate Genome Project assembly group
## _Date: February 18-22, 2019_

VGP-Tools is a collection of tools that operate on DNA sequencing data encoded in a collection
of file formats called collectively VGP-Formats.  The encodings include descriptions of source
data, process intermediates, and the ultimate reconstructed genome assemblies.  There is a core set of ASCII file types based on very simple principles, then specific derived subtypes that add additional constraints in order to represent specific data types.
For example, the
VGP currently collects four core data sets as input into a genome assembly. Three of these are encoded in three different subtypes of the sequence file type, and the fourth in a restriction map file type.  

Below are the file types currently supported by VGP-Formats. By convention file types and subtypes are three letter lower case strings, which can be used as filename suffixes, e.g. dataset1.seq or dataset2.pbr.

- **.seq**   primary file type for sequence objects. There are multiple subtypes of this including
	- **.irp** for Illumina read pairs, which we use to encode Hi-C read data but which can be applied more generally to any read pair protocol,
	- **.pbr** for PacBio long reads and relevant meta-data, 
	- **.10x** for 10X Genomics read clouds with their extracted barcodes,
	- **.ctg** for contigs from an assembly.

- **.rmd**   primary type for restriction map digests.  We use this for primary BioNano .bnx data, but also for derived restriction maps either generated by assembly from primary data, or by *in silico* digestion from sequences.  Subtypes are
	- **.rmb** for BioNano raw data imported from .bnx files
	- **.rmc** for contigs from map assembly as in Bionano .cmap output of their "solve" assembly process

- **.sxs**   primary type for sequence alignments (Sequence Cross Sequence, pronounced like "success").  Subtypes of this are
	- **.rxr** for restriction map comparisons, and 
	- **.map** for representing the relationship between a set of consensus sequences and the reads or other sequences from which they were derived.

- **.scf** a collection of scaffolding suggestions representing putative joins and breaks between sequences in some .seq file.

- **.exs** this supports export of a set of scaffolds or sequences from a VGP-Format file collection as fasta and/or agp with gaps.

- **.lis** this is a utility file type can be used to record arbitrary lists of objects in any of the other types.

The VGP format encoding of each file type is documented in a separate chapter of this document following the overview
given here.  The formal definition of all currently valid specs is provided in the code for the utility **vgpvalidate**
which also provides utilities to reconstruct headers.  The design of VGP formats is based on the following principles:

1.	The format should be trivial to parse as input.  All the burden of encoding is placed on the software that produces the formatted file.

2.	The length of a list should always precede the list (e.g. 3 xxx).  Bracket (.eg [xxx]) or terminator (e.g. xxx0) constructions are not permitted.

3.	The maximum size or total size of items to follow should be specified at the start of a file so that any desired memory allocation can be performed once at the start by the reader.

4.	For every format file type, there is a VGP tool that translates the ASCII format to a terse binary form and another that inverts this conversion.

5.	The ASCII form should not be overly verbose, it is not for human consumption, but simply must be easily interpretable by a human being when and if they need to look at the data.

6.	Complex identifiers or symbolic names for objects are not used.  The nth occurrence of an object of a given type is referred to by the number n in any future context within the file.

7.	A reference to an object is not permitted before its definition.

8.	The provenance of a file must be given as the sequence of tools applied to obtain it, where each tool application is described by its name, version number, command line applied, and date & time performed. 

From another point of view, a VGP formatted file should be readable by a simple parser that can
(a) read the next integer, (b) read the next real number, (c) read the next n symbols, and
(d) skip to the next line, where each read can begin with white space that is skipped.  The
parser should further never require dynamic memory allocation to store objects – the size of
any object or object collection should be given before the first object of that type is described.

Following these principles, VGP formats uses a very simple “1-code” schema in which the data is
encoded in an ASCII file in a sequence of lines where the first character of each line determines
what kind of information the line encodes.  Consider as a working example, the following Illumina Read Pair (irp) file:

```
1 3 seq 1 0            required file type, major and minor version
2 3 irp                optional subtype
# ! 1                  number of provenance lines in the file
# P 2                  number of read pairs in file
# S 4                  number of sequences in file
@ S 5                  maximum number of bp’s in a read
+ S 17                 total number of bp's in file
! 7 VGPpair 3 0.1 ...  provenance line saying how file arose
P                      separator for read pairs - helps human interpretability 
S 5 acgta              forward sequence of pair 1
S 3 gtt                reverse sequence of pair 1
P
S 4 gcta
S 5 ggtac 
```
Like all VGP files, this starts with a set of header lines indicated by a non-alphabetic "1-code" symbol, followed by data lines that always begin with an alphabetic "1-code".  Tokens on a line are separated by a single whitespace character (space or tab).  Variable length lists, including strings, are preceded by their length in keeping with principle 2. The
1-code and subsequent tokens determine when the encoding of expected information on a line is at an end. 
Therefore optional additional information to the end of the line provides an extensibility
mechanism where one can add auxiliary information if desired.  In the example above, the whitespace and 
comments following the encoded information on each line are ignored by a VGP parser.

A further consequence of the 1-code philosophy of VGP lines is that once the initial symbol is read, all the other fields are required.  For this reason, when we want to allow optional information for an object, it must be encoded on separate lines with their own line types that follow the object definition line.

Conceptually VGP files are *immutable*, meaning that we do not expect their contents to change. This means that subsequently in the same file, or more often in future files in a pipeline, we can refer to objects by their ordinal position in a file, 1...n, not requiring named identifiers. This simplifies many things.

### Header lines

Considerable effort is invested on headers in VGP-formats in keeping with principles 3 and 8.

The first header line with type ```1``` must always be a version line confirming the file type and specifying the major and minor
version numbers separated by a whitespace.  This can optionally be followed immediately by a file subtype line with type ```2``` as in the example above 

Additional header lines give information about the number of items
in the file (#-lines), the maximum length of lists (@-lines), and the total number of items in a given list class
(+-lines).  In addition, provenance lines (!-lines) inform one about how the particular file came to be.

We now introduce how we formally describe VGP formats, defining the header lines to illustrate. Using a "casual" context free grammar rule the inital file type declaration has the syntax:

```
    <version_header> = 1 <string:file_type> <major> <minor>
```
where the initial ```1``` indicates that this is a a "1-code" file (as well as this being line 1) and ```<file_type>``` is one of the nine 3-letter file suffixes above.  In accordance with principle 3, strings are encoded with an initial integer giving their length, followed by the literal string of characters, which can contain whitespace other than newlines.

```
   <string> = <int:n> <char>n
```
The initial header line can be followed by an optional subtype line

```
	<subtype_header> = 2 <string:file_subtype>
```
***Gene asks whether the secondary should have a version number?***

Next there are three header line types - #, +, and @ - that allow one to specify the number, total size, and maximum size of objects across a file.  These all have the syntax:

```
    <size_header> = [#+@] <symbol:S> <int>
```
```#```-lines tell you the number of lines in the file of type S.  For line types that encode a list of items, such as
string (a list of characters) or say a list of digest sites, a ```+```-line tells you the total number of items
in all the lists in the file, e.g. "<code>+ S 17</code>" in the example above indicates that altogether the
sequences in the file total 17 bases.  Similarly, an ```@```-line indicates the length of the largest list that
occurs in any given line of the specified type.  

Often the objects in a file are naturally partitioned into groups, e.g. all the read pairs in a flow-cell lane, and the VGP formats support this with lower case symbols as data line indicators.  For these the ```%``` designator indicates the maximum number of objects or total size of list objects within any given group type.  The syntax for these lines is:  

```
    <group_header> = % <symbol:g> [#+] <symbol:S> <int>
```
where ```<g>``` is the group line designator (always a lower case letter by convention) and ```<S>``` is the line type in question.

Another important header line type indicates that references in this file are made to objects in another file. This has the following syntax

```
    <reference_header> = '<' <string:file_name> <symbol:X> <int:nx>
```
The X symbol in this line denotes the line type from the referenced file which identifies the objects to be referred to.  For example an alignment file may refer to sequence objects designated by S lines in another file. The nx number is the number of these items.

A related concept is to refer to another file in which the objects depends upon the contents of the current file.  We denote this in a similar way to the reference line, but with a '>' symbol rather than a '<' symbol.

```
	<forward_header> = '>' <string:file_name>
```
In this case there is no need to indicate the primary objects in the file and their number, since the current file will not refer to them.

The final header line type is provenance or ```!```-lines that record a processing step that was involved
in producing the current file.  Each line contains four strings giving (a) the program name, (b) the version of that program as a string, (c) the command line that was executed, and (d) the date and time it
was run.

```
    <provenance_step> = <string:name> <string:version> <string:command> <string:date>
```

## Data lines defined according to file type

The types of data lines permitted depend on the file type.  We therefore specify here each file type in turn.  Where reference header lines are required we indicate that here, together with what they signify. We remind the reader that while we aim to keep this README up to date, the formal versioned definition of each VGP file type is determined by the validator **VGPvalidate** and documented in its code.

### Sequence files, .seq

A core file type containing sequences, with optional quality scores.

```
g <int:n> <string:group_name>    group with n sequences
P              indicates that the next two sequences are paired
S <string>     the sequence
Q <string>     QV scores in single character phred encoding (ASCII 33+q) 
```
The core lines are the S lines, and this is the only line type which is required.  If P lines are present for pairing, then the number of S lines must be twice the number of P lines.  If Q lines are present then the number of Q lines must be the same as the number of S lines.

The S strings are over the alphabet A, C, G, T.  IUPAC ambiguity codes are not supported. Any unsupported code (including N) is turned into an arbitrary letter with by VGP tools, with quality set to 0 if qualities are present.  DNA strings may be upper or lower case.

The E line is optional, and will not be used within VGP files to refer to sequences.  All references are to the index in the file.  The reason to have an E line is so as to be able to provide a known sequence name when exporting to FASTA or other formats.  We do not intend to keep names for reads, or assembly contigs.

The Q lines are optional.  When present, each symbol of a Q string is an ASCII character as in FASTQ.  So Q strings are over the 94 printable ASCII characters [!-~] and correspond to the range 0 to 93.

The g lines, if present, must form a partition over the sequences.  Both the reads in a pair must be in the same partition.  We use the g lines both for read groups in primary Illumina data, and for read clouds in 10X Genomics data, where we place the barcode in the group_name field.

#### Illumina paired reads, .ipr

This subtype of .seq requires that P lines exist, and that there are no E lines.  We explicitly force you to remove primary read names - if you are determined to encode them you can have them as extensions at the end of the P record, but these will not be visible to the parser.

If group lines are present then they should correspond to sequencing lanes or the equivalent, as in SAM read groups.

**VGPpair** is a VGP tool that takes two .fastq files containing corresponding forward and reverse reads (the usual bioinformatic convention for such) and produces a .irp from the inputs.  Reads within the same lane are placed in a given group. 

#### 10X Genomics read clouds, .10x

This subtype of .seq requires that P lines exist, and that there are no E lines as for .ipr.  It also requires that g lines exist and correspond to subsets of reads with the same barcode.  The literal barcode sequence is by convention given in the group_name field.
The barcodes and linker sequences should be removed from the reads (removing 23bp = 16bp barcode and 7bp linker at the start of read 1 for 10X Genomics).

**VGPcloud** is a VGP tool that takes an .irp-file containing the bar-coded Illumina read pairs
and re-organizes the data into clouds and removes the bar codes.  It understands how barcodes
are encoded in the forward read of each pair, and takes into account potential errors in the
barcode sequence.

#### PacBio Long Reads, .pbr

The final raw data .seq subtype for the time being encode long reads from Pacific Biosciences.  P and E are not permitted, the g group_name should be set to the SMRT_cell header, and a W line must be provided to give well information for the read.  We also allow two extra optional record types to encode signal information that can be used in consensus callers.

```
W <int:well> <int:1st.pulse> <int:last.pulse> <real:score>	read well and pulse range
N <real:A> <real:C> <real:G> <real:T>   SNR in each base channel for read
A <string>                              capped pulse widths
```
The W line is necessary to identify when multiple subreads come from the same well. If present, the N-line give the average SNR in the channels for each base and
the A-line gives the capped pulse width for each base as the character 1, 2, 3 or 4.  Pulse
widths larger than 4 are clipped to 4 as Arrow does not treat widths larger than 4 differently.
Basically short pulses are indications of potential error but any pulse over 4 units
long is almost certainly a good call.  The A string must have the same length as the S string for a given read .

In terms of a regular expression:

```
   (<g-line> (<S-line><W-line>[<N-line><A-line>])n )*
```

**VGPpacbio** is a VGP tool that takes one or more Pacbio subreads.bam or .sam files as input
and extracts the information to make a .pbr file.
 
### Restriction Map Digest, .rmd

This primary file type encodes a general restriction digest, potentially with multiple enzymes with distinct recognition sites.  It can be used both to represent primary data from a BioNano .bnx file, or other source of primary data, or a virtual map derived either by assembly of primary data or by *in silico* digestion of a sequence given a restriction enzyme recognition site, corresponding to the .cmap file type in the BioNano world.  These can be used for consistency checks with proposed assemblies, and to make inferences about scaffolding breaks and joins. 

```
r <int:r> <int:s> <string:site>s	set of r molecules cut with s enzymes, giving the literal recognition sequences of the enzymes
M <int:len> <int:n> <int>n       	molecule: length and list of site locations
R <int:n> <int>n					list of enzyme type per site (from 1..s)
I <int:n> <real>n    				list of n intensities of sites in digest
N <int:n> <real>n    		 		list of n signal to noise ratios per site
```
The R line is only required if there are multiple enzymes specified (s > 1).  The I and N lines are only needed to represent primary data.

In terms of a regular expression:

```
( <r-line> (<M-line> [<R-line>][<I-line>][<N-line>])r )*
```

**VGPbionano** is a VGP tool that takes a Bionano .bnx-file as input and extracts the information to make a .rmd-file.

### Sequence match files, .sxs

This is the primary file type for sequence matches.

```
< <string:filename_a> <char:T> <int:na>        source of A sequences
< <string:filename_b> <char:T> <int:nb>        source of B sequences

A <int:a> <int:b>                       indexes of aligned sequences
I <int:as> <int:ae> <int:bs> <int:be>   start and end in a and in b
Q <int>                                 alignment confidence in phred units
C <string>                              cigar string
T <int:t> <int>t                        list of trace points
U <int:m> <int>m                        list of trace sites in a
V <int:m> <int>m                        list of trace sites in b
M <int>                                 number of matching aligned bases
D <int>                                 number of differences = substitutions + indel bases
```
There must be two included files, each containing some number of lines of named type *T*.  For sequences *T* will be S.  We allow an arbitrary type here so as to also allow restriction map lines from **.rmd** files. It is these objects that the ```a``` and ```b``` index fields on the ```A``` alignment lines refer to.  These can be the same file in the case that an all-versus all alignment process has been run, as in the first step of most assemblers.

The value in the Q field is the phred-scaled confidence that the alignment is true, which is defined as -10log<sub>10</sub> p(alignment is true). This is the mapping quality for programs that generate that quantity.  This can be followed by other method-specific scoring information, which because it falls after the defined fields can be free form.

There are mutliple ways to give more detailed information about the alignment.  A C line supports CIGAR, which gives the complete alignment but can be verbose if the divergence is high.  The T line support evenly spaced trace points as in Gene Myers' [DAZZLER](https://dazzlerblog.wordpress.com/2015/11/05/trace-points/) system

All line types following A are optional.  Typically I will be present and only one of C and T will be used downstream by any one application.

If there are *a* bases in sequence a and *b* bases in sequence b and *m* matches, *s* substitutions, *d* deletions and *i* insertions, then  M = *m* and D = *s* + *i* + *d*. So if we have both M and D then we can calculate *s* and *i* and *d*, using that 2*m* + 2*s* + *i* + *d* = *a* + *b* and *m* + *s* + *d* = *a* and *m* + *s* + *i* = *b*.

### Restriction digest match file, .rxr

This is a closely related format to .sxs, containing alignments of restriction maps rather than alignments between DNA sequences. There are subtle differences in some of the ancillary record types.

```
< <string:filename_a> M <int:na>        source of A molecules
< <string:filename_b> M <int:nb>        source of B molecules

A <int:a> <int:b>                       indexes of aligned sequences
I <int:as> <int:ae> <int:bs> <int:be>   start and end in a and in b
Q <int>                                 mapping quality in phred units
M <int:m>                               number of matched sites
C <string>                              cigar string
D <int>                                 number of unmatched sites
```
There must be two included files, each containing some number of M lines designating molecules with restriction digests.  The U and V lines store lists of the indexes of pairs of matched sites, so both these records must be present if either of them is, and the list sizes on these two lines must be the same, and the same as the value of m on the M line if that is present.  The cigar string on the C line is essentially the same as for sequences, although there is no concept of aligned but mismatching sites (everything must match or be an insertion or deletion).

### Scaffolding information file, .scf

This file encodes information about possible breaks and joins between sequences.  We expect that our assembly process will create a **.seq** file of contigs, and that various methods can be applied to use BioNano, HiC and 10X Genomics data to propose joins between these contigs, and possible breaks in them where they believe that there were missassemblies.

```
< <string:contig_file_name> S <int:nseqs>
< <string:sxs_list_file_name> L <int:nlists>
< <string:rxr_list_file_name> L <int:nlists>

B <int:seq> <int:start> <int:end>                       potential break in sequence somewhere between start and end
J <int:seq_a> <int:seq_b> <[s|e]:end_a> <[s|e]:end_b>   potential 
Q <int:phred_confidence>                                confidence in the break
G <int:gap>                                             estimated gap size in base pairs
X <int:list_id>
y <int:list_id>
```
The join operator specifies which end of each sequence is involved in the join, using single characters ***s*** or ***e*** to designate the start and end.  If the G line is missing then the sequences are presumed to abut.  If the gap is negative then they overlap by the specified number of bases.

The Q line can be present for either J or B lines.  Further score information can be given after the phred score.

The X and Y lines point to evidence for these assertions.

### List file, .lis

This file type just keeps lists of indexes into other VGP file types.  We use this to define subsets of objects in existing VGP files, without needing to create

```
< <string:file_name> X <int:nx>
	
L <int:n> <int>n
```
There must be one input header line, and can be an arbitrary number of L lines. Here ```X``` in the header line is a line type found nx times in the named included file, the n value on an L line determines the number of items in the list, and each item is a positive integer between 1 and nx.

## A possible assembly work flow

**INCOMPLETE Here I want to illustrate a work flow through assembly.**

We view the assembly task as choice of a subset of read alignments that
result in a consistent layout.  These can then be used to generate
consensus contig sequences, which are the subject of the next file
type, which represents contigs and scaffolding.

We also support subsets of alignments which are believed to represent
consistent groups of connections between reads that are derived from truly overlapping locations in the source genome.

#### Representing multiple alignments
We do this with two files: a sequence file of the consensus sequences, and a sequence match file (.sxs) with the alignments of the input sequences to the consensus sequences. 
```
< <string:input_sequence_file> S <int:nS>
> <string:sxs_file>                        this file must have cigars

S <string:sequence>
```
The consensus sequence file must refer to the input sequence file. 


# VGP Tool Manuals

```
1. VGPpair [-vsg] <forward:fastq> <reverse:fastq>
```

VGPpair reads two correlated fastq files and outputs the pairs in .irp format to the
standard output.

The input file names must have a .fastq suffix, e.g. somewhere/foo.fastq, however
the suffix need not be given on the command line as VGPpair will automatically add the
appropriate suffix if it is not present.  That is, "<code>VGPpair foo1 foo2</code>" will
operate on <code>foo1.fastq</code> and <code>foo2.fastq</code>.

The -v option asks VGPpair to output information on its progress to the standard error.
The -s option asks VGPpair to *not* output the quality values or Q-lines, but just the
forward and reverse sequences in F- and R-lines.
The -g option asks VGPpair to group the data into lanes.  In this case the files must
have been produced by standard Illumina software from their more basic .bcl files, and
therefore the .fastq headers encode the instrument, flow cell, lane, etc. in fields
between :'s where the data is in order of flow cell and lane.  VGPpair uses this
information to group reads into lanes.

VGPpair checks the syntax of the .fastq files but does not verify that the DNA and QV
strings are over the appropriate symbols.

```
2. VGPpacbio [-vaU] <data:subreads.[bam|sam]> ...
```

VGPpacbio reads a sequence of Pacbio .bam or .sam files and outputs a .brp file to
standard output.

The input file names must have a .bam or .sam suffix, e.g. somewhere/foo.bam, however
the suffix need not be given on the command line as VGPpacbio will automatically add the
appropriate suffix if it is not present.  That is, "<code>VGPpacbio foo1 foo2</code>" will
operate on <code>foo1.bam</code> and <code>foo2.sam</code> if those are the files present.

The -v option asks VGPpacbio to output information on its progress to the standard error.
The -a option asks VGPpacbio to  output the arrow information in N- and A-lines per bundle,
the default is to not output this information.  The -U option requests that the DNA seuqences
are in upper case (the default is lower case).

Each file is forms a separate group in the output file.
